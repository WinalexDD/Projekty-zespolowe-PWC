---
title: "Analiza porównawcza cen ropy i gazu"
author: "Mackiewicz-Kubiak Aleksander, Pągielska Marta"
date: "2025-?-?"
output:
  pdf_document:
    latex_engine: xelatex
  html_document: default
---

## Pakiety

Do analizy użyto następujących pakietów:

```{r message=FALSE, warning=FALSE}
library(tidyr)
library(gamlss)
library(dplyr)
library(fitdistrplus)
library(usefun)
library(quantmod)
library(scales)
library(copula)
library(psych)
library(MVN)
library(readr)
library(xts)
options(scipen = 999) # celem wyłączenia notacji naukowej
pdf.options(encoding='ISOLatin2.enc')
```

## KROK 1

Do analizy wybrano ceny paliw: ropy oraz gazu ziemnego pochodzące z okresu ponad 20 lat (począwszy od 4 stycznia 2000 r. do 17 czerwca 2022 r. włącznie). Ropa oraz gaz są surowcami energetycznymi, których ceny często reagują na te same czynniki, np. napięcia geopolityczne, decyzje OPEC czy kryzysy energetyczne. Wybrana ropa to ropa typu Brent, która wykorzystywana jest jako jeden z najważniejszych światowych benchmarków cen ropy naftowej. Wydobywana jest z Morza Północnego i służy jako punkt odniesienia dla wyceny około dwóch trzecich globalnych dostaw ropy. Jej cena wpływa zatemna ceny paliw i energii na całym świecie.

Wczytanie danych z pliku CSV:

```{r echo=FALSE, warning=FALSE}
data <- read.csv("oil-and-gas.csv")
head(data)
```

Podział danych na ceny ropy i gazu:

```{r}
oil <- subset(data, Symbol == "Brent Oil", select = c(Date, Close))
gas <- subset(data, Symbol == "Natural Gas", select = c(Date, Close))

oil$Date <- as.Date(oil$Date)
gas$Date <- as.Date(gas$Date)

oil <- xts(oil$Close, order.by = oil$Date)
colnames(oil) <- "oil.Close"
gas <- xts(gas$Close, order.by = gas$Date)
colnames(gas) <- "gas.Close"

head(oil); head(gas)
```

Wizualizacja historycznych cen ropy i gazu.

```{r echo=FALSE}
par(mfrow = c(2, 1))
plot(oil, main="Historyczne ceny ropy", type='l',  xlab = "Data", ylab = "Cena (USD)")
plot(gas, main="Historyczne ceny gazu", type='l', xlab = "Data", ylab = "Cena (USD)")
```

Ceny ropy wykazują duże wahania, w tym gwałtowny wzrost przed rokiem 2008, kiedy to nastąpił kryzys finansowy. Po roku 2014 zaobserwować można spadek cen ropy, zapewne związany z rewolucją łupkową. Wyraźne zaburzenia można odnotować w trakcie pandemi COVID-19, a zatem w okolicach roku 2020. Ogólny trend cen ropy można opisać jako zmienny, w tym silnie reagujący na czynniki globalne i geopolityczne. Ceny gazu ziemnego również cechują się zmiennością, ale w nieco innych momentach niż ropa, co może wskazywać na częściową niezależność rynków. Gwałtowne wzrosty cen gazu pojawiają się w momentach wysokiego zapotrzebowania energetycznego, takich jak kryzysy zimowe czy wojna na Ukrainie.

Straty obliczamy jako różnice wartości cen zamknięcia między kolejnymi dniami. Dodatkowo, w przypadku gdy mamy do czynienia z zyskami a nie stratami, to usuwamy te wartości, gdyż nie one są celem analizy. Dodatkowo, przekształcamy ujemne wartości start na wartości dodanie, by ułatwić dalsze analizy i obliczenia.

```{r echo=FALSE}
differ1<-diff(oil$oil.Close)[-1]
differ1 <- differ1[differ1 < 0]
differ1[differ1 < 0] <- -differ1[differ1 < 0]

differ2<-diff(gas$gas.Close)[-1]
differ2 <- differ2[differ2 < 0]
differ2[differ2 < 0] <- -differ2[differ2 < 0]

par(mfrow = c(2, 1))
plot(differ1, type = "h", main = "Przekształcone straty OIL", ylab = "Strata (USD)")
plot(differ2, type = "h", main = "Przekształcone straty GAS", ylab = "Strata (USD)")
```

Wykresy strat również pokazują nieregularność między cenami gazu i ropy, okresy dużych lub małych strat zupełnie się nie pokrywają. 

## KROK 2

Obliczenie podstawowych statystyk:

```{r echo=FALSE}
summary(differ1)
print_empty_line()
summary(differ2)
```

Widać znacząco różnice między maksymalnymi wartościami, co może wynikać z faktu, że ceny ropy są o wiele większe od cen gazu i dlatego też straty w jej cenach są większe. Mediany obu szeregów strat są bardzo podobne, mimo dużej różnicy w średniej, co może oznaczać, że oba rozkłady są prawoskośne (czego oczekujemy po tych rozkładach strat), a większe możliwe spadki ceny ropy mocniej wpływają na średnią. Oba minima są powyżej 0, co oznacza, że poprzednie transformacje danych zadziałały tak jak chcieliśmy. 

Problemem powyższych przekształceń jest fakt, że szeregi strat dla obu firm niekonieczne muszą być równej długości. Ponieważ naszym celem jest badanie zależności tych szeregów, należy zadbać by były one równej długości. W tym celu wyselekcjonujemy dane z dni, w których obie firmy zanotowały stratę, by te szeregi były jak najbardziej porównywalne, jednocześnie sprawdzając, czy nie usuniemy zbyt dużo danych.

```{r echo=FALSE}
common_mask <- differ1 & differ2

aligned_loss1 <- differ1[common_mask]
aligned_loss2 <- differ2[common_mask]
print("Długość nowych szeregów strat:"); length(aligned_loss2)
print_empty_line()
print("Ilość straconych wartości dla dłuższego szeregu"); max(length(differ2)-length(aligned_loss2), length(differ1)-length(aligned_loss1))
```

Mimo, że usuneliśmy prawie 50% danych to nowe, równe szeregi mają wciąż wystarczającą liczbe obserwacji, by móc przeprowadzać dla nich wiarygodne analizy.

Dopasowanie rozkładów:

```{r include=FALSE}
fit1 <- fitDist(as.numeric(differ1),type="realline")
```

```{r echo=FALSE}
fit1
plot(fit1)
```

Dla wartości strat dla cen ropy został dopasowany rozkład ST3. Zwarte skupienie punktów na pierwszym wykresie sugeruje brak istotnej zależności reszt od wartości dopasowanych. Rozkład reszt względem indeksu wskazuje na losowość błędów, bez systematyczności czy struktury czasowej. Estymacja gęstości rozkładu reszt pokazuje, że reszty mają rozkład normalny. Wykres kwantyl-kwantyl również sugeruje normalność rozkładu reszt, poza widocznym ciężkim ogonem z lewej strony wykresu. 

```{r include=FALSE}
fit2 <- fitDist(as.numeric(differ2),type="realline")
```

```{r echo=FALSE}
fit2
plot(fit2)
```

Dla wartości strat dla cen gazu ponownie został dopasowany rozkład ST3, tym razem z lekko innymi parametrami. Tak jak dla dopasowania dla strat cen ropy, zwarte skupienie punktów na pierwszym wykresie sugeruje brak zależności reszt a rozkład reszt względem indeksu sugeruje losowość błędów. Estymacja gęstości rozkładu reszt ponownie pokazuje, że reszty mają rozkład normalny, co również pokazuje wykres kwantyl-kwantyl, z identycznym ciężkim ogonem z lewej strony wykresu. 

Obliczenie korelacji dla przekształconych strat i pełnych danych cenowych:

```{r echo=FALSE}
print("Współczynnik Pearsona")
cor(aligned_loss1, aligned_loss2, method = "pearson")
print_empty_line()
print("Współczynnik Spearmana")
cor(aligned_loss1, aligned_loss2, method = "spearman")
print_empty_line()
print("Współczynnik Kendalla")
cor(aligned_loss1, aligned_loss2, method = "kendall")
```

Korelacja dla przekształconych strat jest niska, co sugeruje, że spadki cen nie mają ze sobą znaczącej zależności liniowej.

```{r echo=FALSE}
minimum <- min(length(oil$oil.Close), length(gas$gas.Close))

print("Współczynnik Pearsona")
cor(oil$oil.Close[1:minimum], gas$gas.Close[1:minimum], method = "pearson")
print_empty_line()
print("Współczynnik Spearmana")
cor(oil$oil.Close[1:minimum], gas$gas.Close[1:minimum], method = "spearman")
print_empty_line()
print("Współczynnik Kendalla")
cor(oil$oil.Close[1:minimum], gas$gas.Close[1:minimum], method = "kendall")
```
Korelacja dla cen zamknięcia również jest niska, co sugeruje, że ceny nie mają ze sobą znaczącej zależności liniowej. O ile dla strat, które poddaliśmy wielu przekształceniom można się spodziewać niskich wartości korelacji, tak dla cen zamknięcia jest to troche dziwniejsze, jednak porównując oryginalne wykresy cen, można mieć wrażenie jakby te wartości nie były od siebie zbytnio zależne. 

## KROK 3

Dopasowanie modeli kopuły:

```{r echo=FALSE}
aligned_loss1 <- coredata(aligned_loss1)
aligned_loss2 <- coredata(aligned_loss2)
u1 <- pobs(aligned_loss1)
u2 <- pobs(aligned_loss2)
data_matrix <- cbind(u1, u2)
data_matrix <- na.omit(data_matrix)
head(data_matrix)
print_empty_line()
summary(data_matrix)
```

```{r include=FALSE}
gumbel_copula <- gumbelCopula(dim = 2)
frank_copula <- frankCopula(dim = 2)
clayton_copula <- claytonCopula(dim = 2)
normal_copula <- normalCopula(dim = 2)
t_copula <- tCopula(dim = 2, dispstr = "un")
```

1. Gumbela:

```{r echo=FALSE}
fit_gumbel <- fitCopula(gumbel_copula, data_matrix)
summary(fit_gumbel)
```

2. Franka:

```{r echo=FALSE}
fit_frank <- fitCopula(frank_copula, data_matrix)
summary(fit_frank)
```

3. Claytona:

```{r echo=FALSE}
fit_clayton <- fitCopula(clayton_copula, data_matrix)
summary(fit_clayton)
```

4. Normalna:

```{r echo=FALSE}
fit_normal <- fitCopula(normal_copula, data_matrix)
summary(fit_normal)
```

5. T-studenta:

```{r echo=FALSE}
fit_t <- fitCopula(t_copula, data_matrix)
summary(fit_t)
```

```{r echo=FALSE}
LL <- c(logLik(fit_gumbel),logLik(fit_frank),logLik(fit_clayton),logLik(fit_normal),logLik(fit_t))
names(LL) <- c("fit_gumbel", "fit_frank", "fit_clayton", "fit_normal", "fit_t")
print("Kryterium loglikelihood")
print(LL)
print_empty_line()
AIC <- c(AIC(fit_gumbel),AIC(fit_frank),AIC(fit_clayton),AIC(fit_normal),AIC(fit_t))
names(AIC) <- c("fit_gumbel", "fit_frank", "fit_clayton", "fit_normal", "fit_t")
print("Kryterium AIC")
print(AIC)
print_empty_line()
BIC <- c(BIC(fit_gumbel),BIC(fit_frank),BIC(fit_clayton),BIC(fit_normal),BIC(fit_t))
names(BIC) <- c("fit_gumbel", "fit_frank", "fit_clayton", "fit_normal", "fit_t")
print("Kryterium BIC")
print(BIC)
```

Wyznaczenie najlepiej dopasowanej kopuły względem:

1. Kryterium loglikelihood(im większa wartość, tym lepiej dopasowany model):

```{r echo=FALSE}
names(LL)[which.max(LL)]; max(LL)
```

2. Kryterium AIC(im mniejsza wartość, tym lepiej dopasowany model):

```{r echo=FALSE}
names(AIC)[which.min(AIC)]; min(AIC)
```

3. Kryterium BIC(im mniejsza wartość, tym lepiej dopasowany model):

```{r echo=FALSE}
names(BIC)[which.min(BIC)]; min(BIC)
```

Wszystkie ww. kryteria wybrały kopułę normalną jako tą najlepiej dopasowaną. Wizualizacja najlepiej dopasowanej kopuły:

```{r echo=FALSE}
par(mfrow = c(1, 2))
simulated_copula <- rCopula(nrow(data_matrix), get(names(AIC)[which.min(AIC)])@copula)

u1 <- seq(0, 1, length.out = 100)
u2 <- seq(0, 1, length.out = 100)
grid <- expand.grid(u1, u2)

contour(u1, u2, matrix(dCopula(as.matrix(grid), fit_normal@copula), nrow = 100), 
        main = "Wykres konturowy kopuły", 
        xlab = "U1", ylab = "U2", col = "blue")

persp(fit_gumbel@copula, dCopula, main = "Dopasowana kopuła normalna")
```

Wykonanie testu Mardia:

```{r echo=FALSE}
mvn(data = as.matrix(data.frame(aligned_loss1, aligned_loss2)), mvnTest = "mardia")
```

Test Mardia wskazuje, że dane nie pochodzą z dwuwymiarowego rozkładu normalnego.

## KROK 3

Obliczamy wartość zagrożoną (VaR) portfela składającego się z dwóch składników, korzystając zarówno z danych rzeczywistych, jak i danych wygenerowanych na podstawie najlepiej dopasowanej kopuły. Najpierw generowane są dane z dopasowanych rozkładów brzegowych, a później dane z kopuły. Następnie dla każdej próbki i poziomu istotności ($\alpha$) obliczane są optymalne wagi ($\beta$), które minimalizują ryzyko portfela. Obliczenia są wykonywane na dwa sposoby: za pomocą funkcji optymalizującej (optimize) oraz ręcznie, za pomocą iteracji po wszystkich możliwych wartościach $\beta$ z określoną odległością przedziału. Wszystko to, aby upewnić się, że wyniki są spójne i aby móc porównać ich dokładność w różnych sytuacjach. 

```{r include=FALSE}
compute_var <- function(beta, x, alpha = 0.05) {
  portfolio <- beta * x[,1] + (1 - beta) * x[,2]
  return(quantile(portfolio, probs = alpha))
}
```

```{r echo=FALSE}
values_N <- c(500, 1000)
values_Alpha <- c(0.95, 0.99)  
betas <- seq(0, 1, by = 0.0001)
set.seed(5463436)

for (N in values_N) {
  for (alp in values_Alpha) {

    simulated_values1 <- do.call(paste0("r", fit1$family[1]), c(list(N), fit1[fit1$parameters]))
    simulated_values2 <- do.call(paste0("r", fit2$family[1]), c(list(N), fit2[fit2$parameters]))
    simulated_values_dist <- matrix(c(simulated_values1, simulated_values2), nrow = N, ncol = 2)
    
    simulated_values_copula <- rCopula(N, get(names(AIC)[which.min(AIC)])@copula)
    
    simulated_values1 <- do.call(paste0("q", fit1$family[1]), c(list(simulated_values_copula[, 1]), fit1[fit1$parameters]))
    simulated_values2 <- do.call(paste0("q", fit2$family[1]), c(list(simulated_values_copula[, 2]), fit2[fit2$parameters]))
    simulated_values_copula_changed <- data.frame(x1 = simulated_values1, x2 = simulated_values2)

    result_dist <- optimize(compute_var, interval = c(0, 1), x = simulated_values_dist, alpha = alp)
    cat("Wartości Beta (z funkcji optimize) z danych empirycznych dla N =", N, "i Alpha =", alp, 
        "wynosi", round(result_dist$minimum,6))
    print_empty_line()
    
    var_results1 <- data.frame(Beta = numeric(length(betas)), VaR = numeric(length(betas)))

    for (i in seq_along(betas)) {
      var_results1[i, ] <- c(betas[i], compute_var(betas[i], x = simulated_values_dist, alp))
    }
    sorted_var_results1 <- var_results1[order(var_results1$VaR), ]
    
    cat("Wartości Beta (liczona ręcznie) z danych empirycznych dla N =", N, "i Alpha =", alp, "wynosi", round(sorted_var_results1$Beta[1],6), "\n")
    
    result_copula <- optimize(compute_var, interval = c(0, 1), x = simulated_values_copula_changed, alpha = alp)
    cat("Wartości Beta (z funkcji optimize) z danych z kopuły dla N =", N, "i Alpha =", alp, 
        "wynosi", round(result_copula$minimum,6))
    print_empty_line()

    var_results2 <- data.frame(Beta = numeric(length(betas)) ,VaR = numeric(length(betas)))

    for (i in seq_along(betas)) {
      var_results2[i, ] <- c(betas[i], compute_var(betas[i], x = simulated_values_copula_changed, alp))
    }
    
    sorted_var_results2 <- var_results2[order(var_results2$VaR), ]

    cat("Wartości Beta (liczona ręcznie) z danych z kopuły dla N =", N, "i Alpha =", alp, "wynosi", round(sorted_var_results2$Beta[1],6), "\n")
    print_empty_line()
    
  }
}
```

```{r echo=FALSE}
values_N <- c(500, 1000)
values_Alpha <- c(0.95, 0.99)  
betas <- seq(0, 1, by = 0.0001)
set.seed(5463436)

for (N in values_N) {
  for (alp in values_Alpha) {

    simulated_values1 <- do.call(paste0("r", fit1$family[1]), c(list(N), fit1[fit1$parameters]))
    simulated_values2 <- do.call(paste0("r", fit2$family[1]), c(list(N), fit2[fit2$parameters]))
    simulated_values_dist <- matrix(c(simulated_values1, simulated_values2), nrow = N, ncol = 2)
    
    simulated_values_copula <- rCopula(N, get(names(AIC)[which.min(AIC)])@copula)
    
    simulated_values1 <- do.call(paste0("q", fit1$family[1]), c(list(simulated_values_copula[, 1]), fit1[fit1$parameters]))
    simulated_values2 <- do.call(paste0("q", fit2$family[1]), c(list(simulated_values_copula[, 2]), fit2[fit2$parameters]))
    simulated_values_copula_changed <- data.frame(x1 = simulated_values1, x2 = simulated_values2)

    result_dist <- optimize(compute_var, interval = c(0, 1), x = simulated_values_dist, alpha = alp)
    cat("Wartości VaR (z funkcji optimize) z danych empirycznych dla N =", N, "i Alpha =", alp, 
        "wynosi", round(result_dist$objective,6))
    print_empty_line()
    
    var_results1 <- data.frame(Beta = numeric(length(betas)), VaR = numeric(length(betas)))

    for (i in seq_along(betas)) {
      var_results1[i, ] <- c(betas[i], compute_var(betas[i], x = simulated_values_dist, alp))
    }
    sorted_var_results1 <- var_results1[order(var_results1$VaR), ]
    
    cat("Wartości VaR (liczona ręcznie) z danych empirycznych dla N =", N, "i Alpha =", alp, "wynosi", round(sorted_var_results1$VaR[1],6), "\n")
    
    result_copula <- optimize(compute_var, interval = c(0, 1), x = simulated_values_copula_changed, alpha = alp)
    cat("Wartości VaR (z funkcji optimize) z danych z kopuły dla N =", N, "i Alpha =", alp, 
        "wynosi", round(result_copula$objective,6))
    print_empty_line()

    var_results2 <- data.frame(Beta = numeric(length(betas)) ,VaR = numeric(length(betas)))

    for (i in seq_along(betas)) {
      var_results2[i, ] <- c(betas[i], compute_var(betas[i], x = simulated_values_copula_changed, alp))
    }
    
    sorted_var_results2 <- var_results2[order(var_results2$VaR), ]

    cat("Wartości VaR (liczona ręcznie) z danych z kopuły dla N =", N, "i Alpha =", alp, "wynosi", round(sorted_var_results2$VaR[1],6), "\n")
    print_empty_line()
    
  }
}
```